<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于传送门React-Portal]]></title>
    <url>%2F2018%2F01%2F30%2F%E5%85%B3%E4%BA%8E%E4%BC%A0%E9%80%81%E9%97%A8React-Portal%2F</url>
    <content type="text"><![CDATA[什么是Portal在React v16.0的更新中，React给我们带来了一个新特性，那就是Portals，这个单词有一个非常形象的翻译 — “传送门”。 如果大家看过叮当猫，相信对它的一个道具印象非常深刻，那就是任意门。叮当猫的任意门就是一个传送门，当人们钻进这个门，可以从指定的另一个地方出来。 官方解释 Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. 用法render() { // The first argument (child) is any renderable React child, such as an element, string, or fragment. The second argument (container) is a DOM element. return ReactDOM.createPortal( this.props.children, domNode, ); } 为什么我们需要Portal在使用React的时候，如果我们需要在某个组件中使用Dialog，大致代码如下: render() { return ( &lt;div className=&quot;dialog-element-parent&quot;&gt; {components} &lt;Dialog /&gt; &lt;/div&gt; ); } 一般来说，我们希望Dialog显示在屏幕正中央，但是如果div.dialog-element-parent仅仅只是一个小窗口，那我们实现起来就比较麻烦了。 如果我们的项目需要的各类Dialog样式相对较统一，我们可以将Dialog放到组件树的最顶层，然后通过redux等组件间通信方式，来给Dialog发送信息去展示内容。但是这样Dialog的内容无法支持完全定制。 所以我们需要一个Portal来实现我们想要的效果: 声明式的写在一个组件中 并不真正render在被声明的地方 在React v16.0之前，如何实现Portal需要用到ReactDom中的两个函数 unstable_renderSubtreeIntoContainer unmountComponentAtNode export default Class DialogWrap extends React.Component { componentDidMount() { const container = document.createElement(&apos;div&apos;); document.body.appendChild(container); this.container = container; this.renderDialog(this.props); } componentDidUpdate() { this.renderDialog(this.props); } componentWillUnmount() { if (this.container) { ReactDOM.unmountComponentAtNode(this.container); this.container = null; } } renderDialog(props) { ReactDOM.unstable_renderSubtreeIntoContainer( this, &lt;Dialog {...props} /&gt;, // 组件 this.container, // 需要渲染&lt;Dialog /&gt;的Dom node ); } render() { return null; } } 注意，在最新的React v16.0中，这两个函数还能使用。但是推荐替换为createPortal. React v16.0的实现方式export default Class DialogWrap extends React.Component { constructor(props) { super(props); const container = document.createElement(&apos;div&apos;); document.body.appendChild(container); this.container = container; } componentWillUnmount() { if (this.container) { this.container.parentNode.removeChild(this.container); this.container = null; } } render() { return (ReactDOM.createPortal(&lt;Dialog {...props} /&gt;, this.container)); } } React Portal的事件冒泡React v16.0通过createPortal创建出来的组件，它的事件可以传递到其React组件对应的父组件上，而不是真实绑定的Dom node上。通过unstable_renderSubtreeIntoContainer创建出来的组件无法实现该特性的。 总结Portals的典型用法就是当父节点存在 overflow: hidden 或者 z-index 属性的时候，允许子节点打破这些限制。例如Dialog, Modal, tooltips等组件. 文章内容参考自: React官网 - Portals 知乎 - 《传送门: React Portal》 react-component - DialogWrap.tsx]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>-Javascript -React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript权威指南源码分析-扑克牌类]]></title>
    <url>%2F2018%2F01%2F15%2FJavascript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%89%91%E5%85%8B%E7%89%8C%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言 书本介绍: 《Javascript权威指南 第六版》 章节：第9章 类和模块 代码案例: [9.7, 9.8] 在阅读该章节的时候，对原型原理以及衍生知识点一直似懂非懂。通过对示例代码的分析与总结，让我对类的基础知识有更形象的理解。想着记录下来供我后续阅览，于是有了这篇文章。 源代码以下代码来源书本内容，由于自己重新敲了一遍，有些地方会不一致，但是不影响最终展示。 enumeration类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* enumeration函数创建了一个新的枚举类，实参对象表示类的每个实例的名字和值 返回值是一个构造函数，他标示这个新类*/function enumeration(namesToValues) &#123; // enumeration不能作为构造函数 const enumeration = function() &#123; throw &quot;Can&apos;t Instantiate Enumerations&quot;; &#125;; const proto = enumeration.prototype = &#123; toString: function() &#123; return this.name; &#125;, valueOf: function() &#123; return this.value; &#125;, &#125;; enumeration.values = []; // 用于存放枚举对象数组 for (let name in namesToValues) &#123; // for in 会遍历对象的原型链上的所有属性，推荐使用hasOwnProperty过滤 if (!Object.hasOwnProperty.call(namesToValues, name)) &#123; continue; &#125; const e = inherit(proto); e.name = name; // 设置对象name e.value = namesToValues[name]; // 设置对象的值 enumeration[name] = e; // 将对象设置为构造函数的属性 enumeration.values.push(e); &#125; // 添加遍历方法 enumeration.foreach = function(f, c) &#123; for (let i = 0; i &lt; this.values.length; i++) &#123; f.call(c, this.values[i]); &#125; &#125;; return enumeration;&#125;// 继承函数function inherit(p) &#123; if (p === null) throw TypeError(); if (Object.create) &#123; return Object.create(p); &#125; const t = typeof p; if (t !== &quot;object&quot; &amp;&amp; t !== &quot;function&quot;) &#123; throw TypeError(); &#125; function F() &#123;&#125; F.prototype = p; return new F();&#125; poker类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function Poker(suit, rank) &#123; this.suit = suit; this.rank = rank;&#125;// 花色Poker.Suit = Enumeration(&#123; Clubs: 1, Diamonds: 2, Hearts: 3, Spades: 4&#125;);// 牌值Poker.Rank = Enumeration(&#123; Two: 2, Three: 3, Four: 4, Five: 5, Six: 6, Seven: 7, Eight: 8, Nine: 9, Ten: 10, Jack: 11, Queen: 12, King: 13, Ace: 14,&#125;);Poker.prototype.toString = function() &#123; return `$&#123;this.rank.toString()&#125; of $&#123;this.suit.toString()&#125;`;&#125;;// 比较牌值大小Poker.prototype.compareTo = function(that) &#123; if (this.rank &lt; that.rank) return -1; if (this.rank &gt; that.rank) return 1; return 0;&#125;;// 根据牌值计算的排序函数Poker.orderByRank = function(a, b) &#123; return a.compareTo(b);&#125;;// 结合花色和牌值计算的排序函数Poker.orderBySuit = function(a, b) &#123; if (a.suit &lt; b.suit) return -1; if (a.suit &gt; b.suit) return 1; return Poker.orderByRank(a, b);&#125;; deck类12345678910111213141516171819202122232425262728293031323334function Deck() &#123; // 初始化所有的牌 const cards = this.cards = []; Poker.Suit.foreach(function(s) &#123; Poker.Rank.foreach(function(r) &#123; cards.push(new Poker(s, r)); &#125;); &#125;);&#125;// 洗牌: 重新洗牌并返回洗好的牌Deck.prototype.shuffle = function() &#123; const deck = this.cards, len = deck.length; for (let i = len - 1; i &gt; 0; i--) &#123; let r = Math.floor(Math.random() * (i + 1)); let temp; temp = deck[i]; deck[i] = deck[r]; deck[r] = temp; &#125; return this;&#125;;// 发牌Deck.prototype.deal = function(n) &#123; if (this.cards.length &lt; n) &#123; throw &quot;Out of cards&quot;; &#125; return this.cards.splice(this.cards.length - n, n);&#125;;Deck.prototype.getValues = function() &#123; return this.cards;&#125;; 测试代码12345678910111213141516const deck = (new Deck()).shuffle();const hand = deck.deal(13).sort(Poker.orderBySuit);// 查看全部牌console.log(&apos;===== Deck Pockers =====&apos;);deck.getValues().sort(Poker.orderBySuit).forEach(function(card) &#123; console.log(card.toString());&#125;);console.log(&apos;========================\n&apos;);// 查看手牌console.log(&apos;===== Hand Pockers =====&apos;);hand.forEach(function(card) &#123; console.log(card.toString());&#125;);console.log(&apos;========================&apos;); 运行结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657===== Deck Pockers =====Two of ClubsFour of ClubsFive of ClubsSix of ClubsSeven of ClubsEight of ClubsNine of ClubsJack of ClubsQueen of ClubsKing of ClubsTwo of DiamondsThree of DiamondsFour of DiamondsFive of DiamondsSeven of DiamondsEight of DiamondsNine of DiamondsQueen of DiamondsKing of DiamondsAce of DiamondsTwo of HeartsFour of HeartsFive of HeartsSeven of HeartsTen of HeartsKing of HeartsAce of HeartsTwo of SpadesFour of SpadesFive of SpadesSix of SpadesSeven of SpadesEight of SpadesNine of SpadesTen of SpadesJack of SpadesQueen of SpadesKing of SpadesAce of Spades============================= Hand Pockers =====Three of ClubsTen of ClubsAce of ClubsSix of DiamondsTen of DiamondsJack of DiamondsThree of HeartsSix of HeartsEight of HeartsNine of HeartsJack of HeartsQueen of HeartsThree of Spades======================== 其他以上源码放在Git了，可直接下载运行。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Javascript权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于防抖动(Debounce)和节流(Throttle)]]></title>
    <url>%2F2018%2F01%2F08%2F%E5%85%B3%E4%BA%8E%E9%98%B2%E6%8A%96%E5%8A%A8-Debounce-%E5%92%8C%E8%8A%82%E6%B5%81-Throttle%2F</url>
    <content type="text"><![CDATA[了解背景某项目中，需要实现一个及时搜索框，当用户输入关键字即去搜索相关数据。项目框架为React，使用onChange来监听input的输入事件。初步完成之后发现了问题，用户输入一个中文，会多次调用change事件，因每一次拼音的输入都会触发change事件。随即我决定采用延迟调用的方式去处理，沿着这个思路，发现了throttle-debounce，同时对debounce有了初步了解。 什么是Debounce百度百科：按键去抖动，机械按键在按下时，并非按下就接触的很好，尤其是有弹簧片的机械开关，会在接触的瞬间反复开合多次。为了消除这种情况，会在断开闭合后执行一个延时程序，5ms～10ms的延时，让前沿抖动消失后再一次检测键的状态，如果仍保持相同状态电平，则确认为真正有键按下。 123Creates a debounced function that delays invoking `func` until after `wait`milliseconds have elapsed since the last time the debounced function wasinvoked, or until the next browser frame is drawn. 以上来源于: lodash/debounce.js 个人理解：当函数调用后，指定时间内没有再次被调用，则执行。若在指定时间内再次调用，则重新计算时间。 在某些情况下，由于事件被频繁调用(例如：mousemove, keyup)，会造成很多重复性的动作，这些动作可能会造成占用内存，重复调用等资源浪费行为。 这个时候，debounce的作用就是限制这些事件以一定的频率调用，例如限制搜索框的change事件500ms调用一次，这样我们可以避免多次的服务器请求。 什么是Throttle12Creates a throttled function that only invokes `func` at most once per every `wait` milliseconds (or once per browser frame). 以上来源于: lodash/throttle.js 个人理解： 函数在预定义的执行周期内，最多执行一次 例如onscroll事件，在一个无限滚动的内容区域内，我们必须检测滚动条距离底部的位置，如果使用debounce则会造成用户滚动底部停止动作了才去请求数据的情况。 而使用throttle则可以保障我们不断的去检查滚动条的位置，及时获取数据。 如何使用debounce和throttle的轮子已经非常多了，没有必要自己去实现一套。这里推荐一种方式，使用Lodash的自定义库，生成的代码仅2kb。 12npm install -g lodash-clilodash include=debounce,throttle 结论debounce和throttle都可以帮助我们延时执行函数，但是具体该用哪一个就需要按照自己的实际需求去选择了。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
