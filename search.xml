<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[翻译系列: React - Refs and the DOM]]></title>
    <url>%2F2018%2F04%2F09%2F%E7%BF%BB%E8%AF%91%E7%B3%BB%E5%88%97-React-Refs-and-the-DOM%2F</url>
    <content type="text"><![CDATA[通过Refs，用户可以直接访问DOM节点或者React.render()创建的组件实例. 在典型的React数据流中(单向数据流)，props是父子组件交互的唯一途径。通过传递新的props, 可以修改子组件。 但是，在某些情况下可能需要在数据流之外去强制修改子组件。要修改的对象可能是DOM节点也可能是React组件实例。 对于这两种情况，React提供了相应的方法。 When to Use Refs - 什么时候使用Refs这里有几个很好的用例： 管理focus事件、文本选择或者媒体播放 触发命令式动画 集成第三方DOM库 如果可以通过声明式方式去解决，请避免使用refs。 举个例子: Dialog组件不要暴露open(), close()等方法。而是使用isOpen属性去控制。 Don’t Overuse Refs - 不要过度使用Refs当你首先想到通过refs去做些什么的时候，请花点时间思考一下是否能在组件中使用state来达到相应的功能。 通常使用更高层次的state会使结构更清晰。(状态提升) Creating Refs - 创建RefsRefs可以通过React.createRef()创建，同时也可以通过ref属性直接附加到React元素上。 在组件被构造的时候，refs会被赋予一个实例属性，以便他们可以在整个组件中被引用。 123456789class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); &#125; render() &#123; return &lt;div ref=&#123;this.myRef&#125; /&gt;; &#125;&#125; Accessing Refs - 访问Refs当ref被传递给render中的元素后，就可以通过ref的current属性去访问该节点的引用了。 1const node = this.myRef.current; ref的值根据节点的类型决定: 当ref属性作用在HTML标签上，在构造函数中通过React.createRef()创建的ref接受基础的DOM元素作为current的值。 当ref属性作用在自定义的组件上，ref的current等于当前已挂载的组件实例。 不能在无状态组件上使用ref，因为他们没有实例。 下面的例子说明了不同之处： Adding a Ref to a DOM Element这个例子用ref去存储DOM节点 123456789101112131415161718192021222324252627282930313233class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); // create a ref to store the textInput DOM element this.textInput = React.createRef(); this.focusTextInput = this.focusTextInput.bind(this); &#125; focusTextInput() &#123; // Explicitly focus the text input using the raw DOM API // Note: we&apos;re accessing &quot;current&quot; to get the DOM node this.textInput.current.focus(); &#125; render() &#123; // tell React that we want the associate the &lt;input&gt; ref // with the `textInput` that we created in the constructor return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;this.textInput&#125; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.focusTextInput&#125; /&gt; &lt;/div&gt; ); &#125;&#125; React会在组件装载后，将DOM节点元素赋予ref的current属性，并且在卸载后将其置空。 ref的更新发生在componentDidMount和componentDidUpdate之前 Adding a Ref to a Class Component如果想封装CustomTextInput来实现装载结束后立即点击一次的效果，我们可以通过ref去访问CustomTextInput并调用focusTextInput方法。 12345678910111213141516class AutoFocusTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.textInput = React.createRef(); &#125; componentDidMount() &#123; this.textInput.current.focusTextInput(); &#125; render() &#123; return ( &lt;CustomTextInput ref=&#123;this.textInput&#125; /&gt; ); &#125; &#125; 请注意，仅当CustomTextInput被声明为类的情况下才有效。 Refs and Functional Components你不能在无状态组件上添加ref属性，因为他们没有实例。 12345678910111213141516function MyFunctionalComponent() &#123; return &lt;input /&gt;;&#125;class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.textInput = React.createRef(); &#125; render() &#123; // This will *not* work! return ( &lt;MyFunctionalComponent ref=&#123;this.textInput&#125; /&gt; ); &#125;&#125; 当你需要ref的时候，你应该将组件转换成类组件，就像需要生命周期和state一样。 然而，我们可以在无状态组件内部使用ref来引用一个DOM节点或者类组件。 12345678910111213141516171819202122function CustomTextInput(props) &#123; // textInput must be declared here so the ref can refer to it let textInput = React.createRef(); function handleClick() &#123; textInput.current.focus(); &#125; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;textInput&#125; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; );&#125; Exposing DOM Refs to Parent Components - 将Refs暴露给父组件在某些情况下，你可能想通过父组件去访问子组件的DOM节点。 通常不鼓励这种行为，这样会破坏掉组件的封装性。 但是偶尔会用这种方法来触发焦点或者测量子节点的大小或者位置。 虽然你可以给子组件添加ref，但是这不是一个理想的方法，因为你获得的是子组件的实例而不是想要的DOM节点。 另外，对于无状态组件这样是无效的。 在这种情况下，我们推荐暴露子组件的特殊prop。这个prop可以不叫ref(不如InputRef)。子组件将该属性作为对应DOM节点的ref属性。 这样父组件就可以通过中间件来传递ref到子组件上。 这个方式使用类组件和无状态组件。 12345678910111213141516171819function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.inputElement = React.createRef(); &#125; render() &#123; return ( &lt;CustomTextInput inputRef=&#123;this.inputElement&#125; /&gt; ); &#125;&#125; 在上面的例子中，Parent传递自身属性this.inputElement到CustomTextInput的inputRefprop， CustomTextInput将其作为ref属性赋予input。结果，Parent中的this.inputElement.current等同于Input的DOM节点。 注意inputRef在上面的例子中没有什么特殊的意义，仅仅只是一个component的prop。 然而，对于&lt;input&gt;的ref是很重要的，他告诉React附加ref到它的DOM节点上。 即使CustomTextInput是一个无状态组件，依然可以工作。不像ref只能作用在DOM节点和类组件上，对于像inputRef这样的组件属性没有限制。 这种模式的另一个好处是即使组件嵌套的层级很深依然有效。示例如下： 123456789101112131415161718192021222324252627function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;function Parent(props) &#123; return ( &lt;div&gt; My input: &lt;CustomTextInput inputRef=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Grandparent extends React.Component &#123; constructor(props) &#123; super(props); this.inputElement = React.createRef(); &#125; render() &#123; return ( &lt;Parent inputRef=&#123;this.inputElement&#125; /&gt; ); &#125;&#125; 参照上面的例子，GrandParent指定了this.inputElement。 然后通过inputRef这个prop传递给Parent，然后Parent将其通过inputRef传递给CustomTextInput。 最终，CustomTextInput将inputRef加到&lt;input&gt;的ref属性上。 结果就是GrandParent的this.inputElement.current等于CustomTextInput的&lt;input&gt;。 如果可能，我们不推荐暴露DOM节点，但是这的确是一种有用的解决方法。 注意，这种方式需要你添加代码到子组件上。如果你无法控制子组件，你可以通过findDOMNode()，但是不推荐这样做。 Callback Refs - Refs回调React支持另一种方式去设置refs，refs回调，这给refs的设置与取消设置提供了更好的控制。 通过function来代替createRef()，将其传递给ref属性。 function接受HTML的DOM节点或者React组件实例作为参数，这样就可以在其他地方存储或者访问他。 下面的例子实现了一种普通的模式: 使用ref回调去存储DOM节点的引用。 123456789101112131415161718192021222324252627282930313233343536373839class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.textInput = null; this.setTextInputRef = element =&gt; &#123; this.textInput = element; &#125;; this.focusTextInput = () =&gt; &#123; // Focus the text input using the raw DOM API if (this.textInput) this.textInput.focus(); &#125;; &#125; componentDidMount() &#123; // autofocus the input on mount this.focusTextInput(); &#125; render() &#123; // Use the `ref` callback to store a reference to the text input DOM // element in an instance field (for example, this.textInput). return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;this.setTextInputRef&#125; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.focusTextInput&#125; /&gt; &lt;/div&gt; ); &#125;&#125; React会在组件挂载时调用ref回调，同时当组件卸载的时候，ref会变成null。 ref回调在componentDidMount或者componentDidUpdate之前调用。 你可以在组件间传递ref回调，就像上面传递React.createRef()创建的refs对象一样。 1234567891011121314151617function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Parent extends React.Component &#123; render() &#123; return ( &lt;CustomTextInput inputRef=&#123;el =&gt; this.inputElement = el&#125; /&gt; ); &#125;&#125; 在上面的例子中，Parent通过inputRef属性传递ref回调给CustomTextInput， 然后CustomTextInput将inputRef赋予&lt;input&gt;的ref属性。 这样，Parent的this.inputElement就设置成CustomTextInput中&lt;input&gt;元素的DOM节点了。 Legacy API: String Refs - 旧版API：refs字符串如果你之前用过React, 你可能熟悉旧的API中字符串类型的ref属性，像textInput，你可以通过this.refs.textInput访问DOM节点。 我们不建议用这种方式，因为它存在很多问题，同时可能在未来的版本中移除。 Note 如果你要使用this.refs.textInput去访问refs，我们推荐你使用回调模式或者createRef API。 Caveats with callback refs - refs回调注意事项如果ref回调函数被定义为内联函数，在更新期间会被调用两次。 第一次的参数是null，然后才是DOM元素。 这是因为每次重新渲染都会产生一个新的函数实例，所以React会清理旧的，并生成新的ref。 你可以通过将他设置为类的绑定方法来避免这种情况，但是在大多数情况下，他不应该存在。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
        <tag>React翻译系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于传送门React-Portal]]></title>
    <url>%2F2018%2F01%2F30%2F%E5%85%B3%E4%BA%8E%E4%BC%A0%E9%80%81%E9%97%A8React-Portal%2F</url>
    <content type="text"><![CDATA[什么是Portal在React v16.0的更新中，React给我们带来了一个新特性，那就是Portals，这个单词有一个非常形象的翻译 — “传送门”。 如果大家看过叮当猫，相信对它的一个道具印象非常深刻，那就是任意门。叮当猫的任意门就是一个传送门，当人们钻进这个门，可以从指定的另一个地方出来。 官方解释 Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. 用法render() { // The first argument (child) is any renderable React child, such as an element, string, or fragment. The second argument (container) is a DOM element. return ReactDOM.createPortal( this.props.children, domNode, ); } 为什么我们需要Portal在使用React的时候，如果我们需要在某个组件中使用Dialog，大致代码如下: render() { return ( &lt;div className=&quot;dialog-element-parent&quot;&gt; {components} &lt;Dialog /&gt; &lt;/div&gt; ); } 一般来说，我们希望Dialog显示在屏幕正中央，但是如果div.dialog-element-parent仅仅只是一个小窗口，那我们实现起来就比较麻烦了。 如果我们的项目需要的各类Dialog样式相对较统一，我们可以将Dialog放到组件树的最顶层，然后通过redux等组件间通信方式，来给Dialog发送信息去展示内容。但是这样Dialog的内容无法支持完全定制。 所以我们需要一个Portal来实现我们想要的效果: 声明式的写在一个组件中 并不真正render在被声明的地方 在React v16.0之前，如何实现Portal需要用到ReactDom中的两个函数 unstable_renderSubtreeIntoContainer unmountComponentAtNode export default Class DialogWrap extends React.Component { componentDidMount() { const container = document.createElement(&apos;div&apos;); document.body.appendChild(container); this.container = container; this.renderDialog(this.props); } componentDidUpdate() { this.renderDialog(this.props); } componentWillUnmount() { if (this.container) { ReactDOM.unmountComponentAtNode(this.container); this.container = null; } } renderDialog(props) { ReactDOM.unstable_renderSubtreeIntoContainer( this, &lt;Dialog {...props} /&gt;, // 组件 this.container, // 需要渲染&lt;Dialog /&gt;的Dom node ); } render() { return null; } } 注意，在最新的React v16.0中，这两个函数还能使用。但是推荐替换为createPortal. React v16.0的实现方式export default Class DialogWrap extends React.Component { constructor(props) { super(props); const container = document.createElement(&apos;div&apos;); document.body.appendChild(container); this.container = container; } componentWillUnmount() { if (this.container) { this.container.parentNode.removeChild(this.container); this.container = null; } } render() { return (ReactDOM.createPortal(&lt;Dialog {...props} /&gt;, this.container)); } } React Portal的事件冒泡React v16.0通过createPortal创建出来的组件，它的事件可以传递到其React组件对应的父组件上，而不是真实绑定的Dom node上。通过unstable_renderSubtreeIntoContainer创建出来的组件无法实现该特性的。 总结Portals的典型用法就是当父节点存在 overflow: hidden 或者 z-index 属性的时候，允许子节点打破这些限制。例如Dialog, Modal, tooltips等组件. 文章内容参考自: React官网 - Portals 知乎 - 《传送门: React Portal》 react-component - DialogWrap.tsx]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript权威指南源码分析-扑克牌类]]></title>
    <url>%2F2018%2F01%2F15%2FJavascript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%89%91%E5%85%8B%E7%89%8C%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言 书本介绍: 《Javascript权威指南 第六版》 章节：第9章 类和模块 代码案例: [9.7, 9.8] 在阅读该章节的时候，对原型原理以及衍生知识点一直似懂非懂。通过对示例代码的分析与总结，让我对类的基础知识有更形象的理解。想着记录下来供我后续阅览，于是有了这篇文章。 源代码以下代码来源书本内容，由于自己重新敲了一遍，有些地方会不一致，但是不影响最终展示。 enumeration类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* enumeration函数创建了一个新的枚举类，实参对象表示类的每个实例的名字和值 返回值是一个构造函数，他标示这个新类*/function enumeration(namesToValues) &#123; // enumeration不能作为构造函数 const enumeration = function() &#123; throw &quot;Can&apos;t Instantiate Enumerations&quot;; &#125;; const proto = enumeration.prototype = &#123; toString: function() &#123; return this.name; &#125;, valueOf: function() &#123; return this.value; &#125;, &#125;; enumeration.values = []; // 用于存放枚举对象数组 for (let name in namesToValues) &#123; // for in 会遍历对象的原型链上的所有属性，推荐使用hasOwnProperty过滤 if (!Object.hasOwnProperty.call(namesToValues, name)) &#123; continue; &#125; const e = inherit(proto); e.name = name; // 设置对象name e.value = namesToValues[name]; // 设置对象的值 enumeration[name] = e; // 将对象设置为构造函数的属性 enumeration.values.push(e); &#125; // 添加遍历方法 enumeration.foreach = function(f, c) &#123; for (let i = 0; i &lt; this.values.length; i++) &#123; f.call(c, this.values[i]); &#125; &#125;; return enumeration;&#125;// 继承函数function inherit(p) &#123; if (p === null) throw TypeError(); if (Object.create) &#123; return Object.create(p); &#125; const t = typeof p; if (t !== &quot;object&quot; &amp;&amp; t !== &quot;function&quot;) &#123; throw TypeError(); &#125; function F() &#123;&#125; F.prototype = p; return new F();&#125; poker类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function Poker(suit, rank) &#123; this.suit = suit; this.rank = rank;&#125;// 花色Poker.Suit = Enumeration(&#123; Clubs: 1, Diamonds: 2, Hearts: 3, Spades: 4&#125;);// 牌值Poker.Rank = Enumeration(&#123; Two: 2, Three: 3, Four: 4, Five: 5, Six: 6, Seven: 7, Eight: 8, Nine: 9, Ten: 10, Jack: 11, Queen: 12, King: 13, Ace: 14,&#125;);Poker.prototype.toString = function() &#123; return `$&#123;this.rank.toString()&#125; of $&#123;this.suit.toString()&#125;`;&#125;;// 比较牌值大小Poker.prototype.compareTo = function(that) &#123; if (this.rank &lt; that.rank) return -1; if (this.rank &gt; that.rank) return 1; return 0;&#125;;// 根据牌值计算的排序函数Poker.orderByRank = function(a, b) &#123; return a.compareTo(b);&#125;;// 结合花色和牌值计算的排序函数Poker.orderBySuit = function(a, b) &#123; if (a.suit &lt; b.suit) return -1; if (a.suit &gt; b.suit) return 1; return Poker.orderByRank(a, b);&#125;; deck类12345678910111213141516171819202122232425262728293031323334function Deck() &#123; // 初始化所有的牌 const cards = this.cards = []; Poker.Suit.foreach(function(s) &#123; Poker.Rank.foreach(function(r) &#123; cards.push(new Poker(s, r)); &#125;); &#125;);&#125;// 洗牌: 重新洗牌并返回洗好的牌Deck.prototype.shuffle = function() &#123; const deck = this.cards, len = deck.length; for (let i = len - 1; i &gt; 0; i--) &#123; let r = Math.floor(Math.random() * (i + 1)); let temp; temp = deck[i]; deck[i] = deck[r]; deck[r] = temp; &#125; return this;&#125;;// 发牌Deck.prototype.deal = function(n) &#123; if (this.cards.length &lt; n) &#123; throw &quot;Out of cards&quot;; &#125; return this.cards.splice(this.cards.length - n, n);&#125;;Deck.prototype.getValues = function() &#123; return this.cards;&#125;; 测试代码12345678910111213141516const deck = (new Deck()).shuffle();const hand = deck.deal(13).sort(Poker.orderBySuit);// 查看全部牌console.log(&apos;===== Deck Pockers =====&apos;);deck.getValues().sort(Poker.orderBySuit).forEach(function(card) &#123; console.log(card.toString());&#125;);console.log(&apos;========================\n&apos;);// 查看手牌console.log(&apos;===== Hand Pockers =====&apos;);hand.forEach(function(card) &#123; console.log(card.toString());&#125;);console.log(&apos;========================&apos;); 运行结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657===== Deck Pockers =====Two of ClubsFour of ClubsFive of ClubsSix of ClubsSeven of ClubsEight of ClubsNine of ClubsJack of ClubsQueen of ClubsKing of ClubsTwo of DiamondsThree of DiamondsFour of DiamondsFive of DiamondsSeven of DiamondsEight of DiamondsNine of DiamondsQueen of DiamondsKing of DiamondsAce of DiamondsTwo of HeartsFour of HeartsFive of HeartsSeven of HeartsTen of HeartsKing of HeartsAce of HeartsTwo of SpadesFour of SpadesFive of SpadesSix of SpadesSeven of SpadesEight of SpadesNine of SpadesTen of SpadesJack of SpadesQueen of SpadesKing of SpadesAce of Spades============================= Hand Pockers =====Three of ClubsTen of ClubsAce of ClubsSix of DiamondsTen of DiamondsJack of DiamondsThree of HeartsSix of HeartsEight of HeartsNine of HeartsJack of HeartsQueen of HeartsThree of Spades======================== 其他以上源码放在Git了，可直接下载运行。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Javascript权威指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于防抖动(Debounce)和节流(Throttle)]]></title>
    <url>%2F2018%2F01%2F08%2F%E5%85%B3%E4%BA%8E%E9%98%B2%E6%8A%96%E5%8A%A8-Debounce-%E5%92%8C%E8%8A%82%E6%B5%81-Throttle%2F</url>
    <content type="text"><![CDATA[了解背景某项目中，需要实现一个及时搜索框，当用户输入关键字即去搜索相关数据。项目框架为React，使用onChange来监听input的输入事件。初步完成之后发现了问题，用户输入一个中文，会多次调用change事件，因每一次拼音的输入都会触发change事件。随即我决定采用延迟调用的方式去处理，沿着这个思路，发现了throttle-debounce，同时对debounce有了初步了解。 什么是Debounce百度百科：按键去抖动，机械按键在按下时，并非按下就接触的很好，尤其是有弹簧片的机械开关，会在接触的瞬间反复开合多次。为了消除这种情况，会在断开闭合后执行一个延时程序，5ms～10ms的延时，让前沿抖动消失后再一次检测键的状态，如果仍保持相同状态电平，则确认为真正有键按下。 123Creates a debounced function that delays invoking `func` until after `wait`milliseconds have elapsed since the last time the debounced function wasinvoked, or until the next browser frame is drawn. 以上来源于: lodash/debounce.js 个人理解：当函数调用后，指定时间内没有再次被调用，则执行。若在指定时间内再次调用，则重新计算时间。 在某些情况下，由于事件被频繁调用(例如：mousemove, keyup)，会造成很多重复性的动作，这些动作可能会造成占用内存，重复调用等资源浪费行为。 这个时候，debounce的作用就是限制这些事件以一定的频率调用，例如限制搜索框的change事件500ms调用一次，这样我们可以避免多次的服务器请求。 什么是Throttle12Creates a throttled function that only invokes `func` at most once per every `wait` milliseconds (or once per browser frame). 以上来源于: lodash/throttle.js 个人理解： 函数在预定义的执行周期内，最多执行一次 例如onscroll事件，在一个无限滚动的内容区域内，我们必须检测滚动条距离底部的位置，如果使用debounce则会造成用户滚动底部停止动作了才去请求数据的情况。 而使用throttle则可以保障我们不断的去检查滚动条的位置，及时获取数据。 如何使用debounce和throttle的轮子已经非常多了，没有必要自己去实现一套。这里推荐一种方式，使用Lodash的自定义库，生成的代码仅2kb。 12npm install -g lodash-clilodash include=debounce,throttle 结论debounce和throttle都可以帮助我们延时执行函数，但是具体该用哪一个就需要按照自己的实际需求去选择了。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
</search>
